export declare const B2_pi_over_180: number;
export declare const B2_180_over_pi: number;
export declare const B2_two_pi: number;
export declare function B2Abs(n: number): number;
export declare function B2Min(a: number, b: number): number;
export declare function B2Max(a: number, b: number): number;
export declare function B2Clamp(a: number, lo: number, hi: number): number;
export declare function B2Swap(a: any[], b: any[]): void;
export declare function B2IsValid(n: number): boolean;
export declare function B2Sq(n: number): number;
export declare function B2InvSqrt(n: number): number;
export declare function B2Sqrt(n: number): number;
export declare function B2Pow(x: number, y: number): number;
export declare function B2DegToRad(degrees: number): number;
export declare function B2RadToDeg(radians: number): number;
export declare function B2Cos(radians: number): number;
export declare function B2Sin(radians: number): number;
export declare function B2Acos(n: number): number;
export declare function B2Asin(n: number): number;
export declare function B2Atan2(y: number, x: number): number;
export declare function B2NextPowerOfTwo(x: number): number;
export declare function B2IsPowerOfTwo(x: number): boolean;
export declare function B2Random(): number;
export declare function B2RandomRange(lo: number, hi: number): number;
export declare class B2Vec2 {
    static ZERO: B2Vec2;
    static UNITX: B2Vec2;
    static UNITY: B2Vec2;
    static s_t0: B2Vec2;
    static s_t1: B2Vec2;
    static s_t2: B2Vec2;
    static s_t3: B2Vec2;
    x: number;
    y: number;
    constructor(x?: number, y?: number);
    Clone(): B2Vec2;
    SetZero(): B2Vec2;
    Set(x: number, y: number): B2Vec2;
    Copy(other: B2Vec2): B2Vec2;
    SelfAdd(v: B2Vec2): B2Vec2;
    SelfAddXY(x: number, y: number): B2Vec2;
    SelfSub(v: B2Vec2): B2Vec2;
    SelfSubXY(x: number, y: number): B2Vec2;
    SelfMul(s: number): B2Vec2;
    SelfMulAdd(s: number, v: B2Vec2): B2Vec2;
    SelfMulSub(s: number, v: B2Vec2): B2Vec2;
    Dot(v: B2Vec2): number;
    Cross(v: B2Vec2): number;
    Length(): number;
    LengthSquared(): number;
    Normalize(): number;
    SelfNormalize(): B2Vec2;
    SelfRotate(radians: number): B2Vec2;
    IsValid(): boolean;
    SelfCrossVS(s: number): B2Vec2;
    SelfCrossSV(s: number): B2Vec2;
    SelfMinV(v: B2Vec2): B2Vec2;
    SelfMaxV(v: B2Vec2): B2Vec2;
    SelfAbs(): B2Vec2;
    SelfNeg(): B2Vec2;
    SelfSkew(): B2Vec2;
    static MakeArray(length: number): B2Vec2[];
    static AbsV(v: B2Vec2, out: B2Vec2): B2Vec2;
    static MinV(a: B2Vec2, b: B2Vec2, out: B2Vec2): B2Vec2;
    static MaxV(a: B2Vec2, b: B2Vec2, out: B2Vec2): B2Vec2;
    static ClampV(v: B2Vec2, lo: B2Vec2, hi: B2Vec2, out: B2Vec2): B2Vec2;
    static RotateV(v: B2Vec2, radians: number, out: B2Vec2): B2Vec2;
    static DotVV(a: B2Vec2, b: B2Vec2): number;
    static CrossVV(a: B2Vec2, b: B2Vec2): number;
    static CrossVS(v: B2Vec2, s: number, out: B2Vec2): B2Vec2;
    static CrossVOne(v: B2Vec2, out: B2Vec2): B2Vec2;
    static CrossSV(s: number, v: B2Vec2, out: B2Vec2): B2Vec2;
    static CrossOneV(v: B2Vec2, out: B2Vec2): B2Vec2;
    static AddVV(a: B2Vec2, b: B2Vec2, out: B2Vec2): B2Vec2;
    static SubVV(a: B2Vec2, b: B2Vec2, out: B2Vec2): B2Vec2;
    static MulSV(s: number, v: B2Vec2, out: B2Vec2): B2Vec2;
    static MulVS(v: B2Vec2, s: number, out: B2Vec2): B2Vec2;
    static AddVMulSV(a: B2Vec2, s: number, b: B2Vec2, out: B2Vec2): B2Vec2;
    static SubVMulSV(a: B2Vec2, s: number, b: B2Vec2, out: B2Vec2): B2Vec2;
    static AddVCrossSV(a: B2Vec2, s: number, v: B2Vec2, out: B2Vec2): B2Vec2;
    static MidVV(a: B2Vec2, b: B2Vec2, out: B2Vec2): B2Vec2;
    static ExtVV(a: B2Vec2, b: B2Vec2, out: B2Vec2): B2Vec2;
    static IsEqualToV(a: B2Vec2, b: B2Vec2): boolean;
    static DistanceVV(a: B2Vec2, b: B2Vec2): number;
    static DistanceSquaredVV(a: B2Vec2, b: B2Vec2): number;
    static NegV(v: B2Vec2, out: B2Vec2): B2Vec2;
}
export declare const B2Vec2_zero: B2Vec2;
export declare class B2Vec3 {
    static ZERO: B2Vec3;
    static s_t0: B2Vec3;
    x: number;
    y: number;
    z: number;
    constructor(x?: number, y?: number, z?: number);
    Clone(): B2Vec3;
    SetZero(): B2Vec3;
    SetXYZ(x: number, y: number, z: number): B2Vec3;
    Copy(other: B2Vec3): B2Vec3;
    SelfNeg(): B2Vec3;
    SelfAdd(v: B2Vec3): B2Vec3;
    SelfAddXYZ(x: number, y: number, z: number): B2Vec3;
    SelfSub(v: B2Vec3): B2Vec3;
    SelfSubXYZ(x: number, y: number, z: number): B2Vec3;
    SelfMul(s: number): B2Vec3;
    static DotV3V3(a: B2Vec3, b: B2Vec3): number;
    static CrossV3V3(a: B2Vec3, b: B2Vec3, out: B2Vec3): B2Vec3;
}
export declare class B2Mat22 {
    static IDENTITY: B2Mat22;
    ex: B2Vec2;
    ey: B2Vec2;
    Clone(): B2Mat22;
    static FromVV(c1: B2Vec2, c2: B2Vec2): B2Mat22;
    static FromSSSS(r1c1: number, r1c2: number, r2c1: number, r2c2: number): B2Mat22;
    static FromAngle(radians: number): B2Mat22;
    SetSSSS(r1c1: number, r1c2: number, r2c1: number, r2c2: number): B2Mat22;
    SetVV(c1: B2Vec2, c2: B2Vec2): B2Mat22;
    SetAngle(radians: number): B2Mat22;
    Copy(other: B2Mat22): B2Mat22;
    SetIdentity(): B2Mat22;
    SetZero(): B2Mat22;
    GetAngle(): number;
    GetInverse(out: B2Mat22): B2Mat22;
    Solve(b_x: number, b_y: number, out: B2Vec2): B2Vec2;
    SelfAbs(): B2Mat22;
    SelfInv(): B2Mat22;
    SelfAddM(M: B2Mat22): B2Mat22;
    SelfSubM(M: B2Mat22): B2Mat22;
    static AbsM(M: B2Mat22, out: B2Mat22): B2Mat22;
    static MulMV(M: B2Mat22, v: B2Vec2, out: B2Vec2): B2Vec2;
    static MulTMV(M: B2Mat22, v: B2Vec2, out: B2Vec2): B2Vec2;
    static AddMM(A: B2Mat22, B: B2Mat22, out: B2Mat22): B2Mat22;
    static MulMM(A: B2Mat22, B: B2Mat22, out: B2Mat22): B2Mat22;
    static MulTMM(A: B2Mat22, B: B2Mat22, out: B2Mat22): B2Mat22;
}
export declare class B2Mat33 {
    static IDENTITY: B2Mat33;
    ex: B2Vec3;
    ey: B2Vec3;
    ez: B2Vec3;
    Clone(): B2Mat33;
    SetVVV(c1: B2Vec3, c2: B2Vec3, c3: B2Vec3): B2Mat33;
    Copy(other: B2Mat33): B2Mat33;
    SetIdentity(): B2Mat33;
    SetZero(): B2Mat33;
    SelfAddM(M: B2Mat33): B2Mat33;
    Solve33(b_x: number, b_y: number, b_z: number, out: B2Vec3): B2Vec3;
    Solve22(b_x: number, b_y: number, out: B2Vec2): B2Vec2;
    GetInverse22(M: B2Mat33): void;
    GetSymInverse33(M: B2Mat33): void;
    static MulM33V3(A: B2Mat33, v: B2Vec3, out: B2Vec3): B2Vec3;
    static MulM33XYZ(A: B2Mat33, x: number, y: number, z: number, out: B2Vec3): B2Vec3;
    static MulM33V2(A: B2Mat33, v: B2Vec2, out: B2Vec2): B2Vec2;
    static MulM33XY(A: B2Mat33, x: number, y: number, out: B2Vec2): B2Vec2;
}
export declare class B2Rot {
    static IDENTITY: B2Rot;
    s: number;
    c: number;
    constructor(angle?: number);
    Clone(): B2Rot;
    Copy(other: B2Rot): B2Rot;
    SetAngle(angle: number): B2Rot;
    SetIdentity(): B2Rot;
    GetAngle(): number;
    GetXAxis(out: B2Vec2): B2Vec2;
    GetYAxis(out: B2Vec2): B2Vec2;
    static MulRR(q: B2Rot, r: B2Rot, out: B2Rot): B2Rot;
    static MulTRR(q: B2Rot, r: B2Rot, out: B2Rot): B2Rot;
    static MulRV(q: B2Rot, v: B2Vec2, out: B2Vec2): B2Vec2;
    static MulTRV(q: B2Rot, v: B2Vec2, out: B2Vec2): B2Vec2;
}
export declare class B2Transform {
    static IDENTITY: B2Transform;
    p: B2Vec2;
    q: B2Rot;
    Clone(): B2Transform;
    Copy(other: B2Transform): B2Transform;
    SetIdentity(): B2Transform;
    SetPositionRotation(position: B2Vec2, q: B2Rot): B2Transform;
    SetPositionAngle(pos: B2Vec2, a: number): B2Transform;
    SetPosition(position: B2Vec2): B2Transform;
    SetPositionXY(x: number, y: number): B2Transform;
    SetRotation(rotation: B2Rot): B2Transform;
    SetRotationAngle(radians: number): B2Transform;
    GetPosition(): B2Vec2;
    GetRotation(): B2Rot;
    GetRotationAngle(): number;
    GetAngle(): number;
    static MulXV(T: B2Transform, v: B2Vec2, out: B2Vec2): B2Vec2;
    static MulTXV(T: B2Transform, v: B2Vec2, out: B2Vec2): B2Vec2;
    static MulXX(A: B2Transform, B: B2Transform, out: B2Transform): B2Transform;
    static MulTXX(A: B2Transform, B: B2Transform, out: B2Transform): B2Transform;
}
export declare class B2Sweep {
    localCenter: B2Vec2;
    c0: B2Vec2;
    c: B2Vec2;
    a0: number;
    a: number;
    alpha0: number;
    Clone(): B2Sweep;
    Copy(other: B2Sweep): B2Sweep;
    GetTransform(xf: B2Transform, beta: number): B2Transform;
    Advance(alpha: number): void;
    Normalize(): void;
}
