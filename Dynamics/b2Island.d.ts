import { B2Vec2 } from '../Common/b2Math';
import { B2Contact } from './Contacts/b2Contact';
import { B2ContactVelocityConstraint } from './Contacts/b2ContactSolver';
import { B2Joint } from './Joints/b2Joint';
import { B2Body } from './b2Body';
import { B2TimeStep, B2Profile, B2Position, B2Velocity } from './b2TimeStep';
import { B2ContactListener } from './b2WorldCallbacks';
export declare class B2Island {
    m_allocator: any;
    m_listener: B2ContactListener;
    m_bodies: B2Body[];
    m_contacts: B2Contact[];
    m_joints: B2Joint[];
    m_positions: B2Position[];
    m_velocities: B2Velocity[];
    m_bodyCount: number;
    m_jointCount: number;
    m_contactCount: number;
    m_bodyCapacity: number;
    m_contactCapacity: number;
    m_jointCapacity: number;
    Initialize(bodyCapacity: number, contactCapacity: number, jointCapacity: number, allocator: any, listener: B2ContactListener): void;
    Clear(): void;
    AddBody(body: B2Body): void;
    AddContact(contact: B2Contact): void;
    AddJoint(joint: B2Joint): void;
    private static s_timer;
    private static s_solverData;
    private static s_contactSolverDef;
    private static s_contactSolver;
    private static s_translation;
    Solve(profile: B2Profile, step: B2TimeStep, gravity: B2Vec2, allowSleep: boolean): void;
    SolveTOI(subStep: B2TimeStep, toiIndexA: number, toiIndexB: number): void;
    private static s_impulse;
    Report(constraints: B2ContactVelocityConstraint[]): void;
}
